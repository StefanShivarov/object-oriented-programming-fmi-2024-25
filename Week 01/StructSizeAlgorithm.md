## Подравняване на структури ##

Паметта е байт-адресуема, тоест може да се достъпва всеки байт индивидуално.

Член-данните на една структура се разполагат в паметта в реда, в който са декларирани. Подравняването на една структура става по големината на най-голямата член данна.   

## Алгоритъм за намиране на големина на структура ##

1. Големината на структурата трябва да се дели на големината на най-голямата примитивна член-данна.
2. Всяка променлива трябва да е на адрес (започвайки от 0), който е кратен на големината й.

**Извод:** За постигане на минимален размер на структурата, трябва да подредим член-данните, така че големините им да са в нарастващ ред. (т.е. член-данните са сортирани в низходящ ред според големината им)

## Пример за 2 структури, които имат едни и същи член-данни, но различни рамери ##

```cpp
struct A{
    int x;        // 4 байта
    double y;     // първото число което се дели на 8 е 8, затова 
                  // double променливата ще "започне" на адрес 8  
    int z;        // първият свободен адрес е 16, 16 е кратно на 
                  // 4, следователно int променливата ще "започне"
                  // на адрес 16, 16 + 4 = 20, но 20 не се дели на 8
                  // първото число, което се дели на 8 е 24 
};

int main(){
    //Функцията sizeof() ще върне размера на структурата 
    sizeof(A); // = 24
}
```

```cpp
struct B{
    int x;      // 4 байта
    int z;      // 4 се дели на 4, 4 + 4 = 8, първият свободен е 8
    double y;   // 8 + 8 = 16
};

int main(){
    sizeof(A); // = 16
}
```
## Размер на празна структура ##

```cpp
struct E{};

int main(){
    sizeof(E) // = 1
}
```
- Защо размерът на празна структура е 1, а не 0? 
    - Стандартът на С++ не позволя обекти с нулев размер. Това е така, защото всяка инстанция на структура (или клас) трябва да има уникален адрес в паметта. Не бихме искали два обекта от една и съща структура(или клас) да се съхраняват на едно и също място в паметта.

## Пример за размер на структура, която има член-данни други структури ##

```cpp
struct D{
    double y;
    int x;
    int z;
};

struct J {
    E e;
    D d;        //sizeof(D) = 16;
    int a;
};

int main(){
    sizeof(J); // = 32
}
```
- Вече знаем, че размерът на структурата Е е 1.
- Очакването ни би било структурата D да започне на адрес 16, но НЕ! Подравняването става по най-голямата ПРИМИТИВНА променливи (дори и при вложени структури). 
- Тоест подравняването ще е по double-a от структурата D. И сега структурата D ще започне на адрес 8 (първият кратен на първата член-данна на D). 8 + 16 = 24. 24 е кратно на 4. 24 + 4 = 28, но 28 НЕ се дели на 8 следователно `sizeof(J) = 32`, а 32 е първото число кратно на 8. 